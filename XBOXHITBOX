-- LocalScript: Robust "Big Heads (other players only)" v2
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- Where characters live in your game
local PLAYERS_FOLDER = Workspace:FindFirstChild("Players") or Workspace

-- Desired head size (13)
local HEAD_SIZE = Vector3.new(13, 13, 13)

local function safeDiv(a, b)
	return Vector3.new(a.X / (b.X ~= 0 and b.X or 1),
	                   a.Y / (b.Y ~= 0 and b.Y or 1),
	                   a.Z / (b.Z ~= 0 and b.Z or 1))
end
local function safeMul(a, b)
	return Vector3.new(a.X * b.X, a.Y * b.Y, a.Z * b.Z)
end

local function enforceHead(head, model)
	if not head or not head.Parent then return end
	-- skip your own character
	if model == LocalPlayer.Character then return end

	-- store original head size once (so repeated runs don't compound)
	if not head:GetAttribute("OriginalHeadSize") then
		head:SetAttribute("OriginalHeadSize", head.Size)
	end
	local origSize = head:GetAttribute("OriginalHeadSize") or head.Size
	local scaleFactor = safeDiv(HEAD_SIZE, origSize)

	-- if there's a mesh, store original mesh scale then compute new scale
	local mesh = head:FindFirstChildOfClass("SpecialMesh")
	if mesh then
		if not mesh:GetAttribute("OriginalMeshScale") then
			mesh:SetAttribute("OriginalMeshScale", mesh.Scale)
		end
		local origMeshScale = mesh:GetAttribute("OriginalMeshScale") or mesh.Scale
		local newMeshScale = safeMul(origMeshScale, scaleFactor)
		pcall(function() mesh.Scale = newMeshScale end)
	end

	-- apply to the head part (this affects client-side hitbox for local raycasts)
	pcall(function()
		head.Size = HEAD_SIZE
		head.CanCollide = false
		head.Massless = true
	end)
	head:SetAttribute("BigHead_ClientApplied", true)

	-- keep forcing size and cancollide until head is removed
	local sizeConn, collideConn, ancestryConn
	sizeConn = head:GetPropertyChangedSignal("Size"):Connect(function()
		if not head or not head.Parent then
			sizeConn:Disconnect()
			if collideConn then collideConn:Disconnect() end
			if ancestryConn then ancestryConn:Disconnect() end
			return
		end
		if head.Size ~= HEAD_SIZE then
			pcall(function() head.Size = HEAD_SIZE end)
		end
	end)
	collideConn = head:GetPropertyChangedSignal("CanCollide"):Connect(function()
		if head and head.CanCollide then
			pcall(function() head.CanCollide = false end)
		end
	end)
	ancestryConn = head.AncestryChanged:Connect(function(_, parent)
		if not parent then
			if sizeConn then sizeConn:Disconnect() end
			if collideConn then collideConn:Disconnect() end
			if ancestryConn then ancestryConn:Disconnect() end
		end
	end)
end

local function handleModel(model)
	if not model or not model:IsA("Model") then return end
	-- skip if it's local player's character
	if model == LocalPlayer.Character then return end

	-- try immediate apply if head exists
	local head = model:FindFirstChild("Head")
	if head and head:IsA("BasePart") then
		enforceHead(head, model)
	end

	-- watch for Head being added later (respawn or replacement)
	local childConn
	childConn = model.ChildAdded:Connect(function(child)
		if child and child.Name == "Head" and child:IsA("BasePart") then
			task.wait(0.05) -- let Roblox finish setup
			enforceHead(child, model)
		end
	end)

	-- if model removed, disconnect listener
	local ancConn
	ancConn = model.AncestryChanged:Connect(function(_, parent)
		if not parent then
			if childConn then childConn:Disconnect() end
			if ancConn then ancConn:Disconnect() end
		end
	end)
end

-- apply to existing children in the players folder
for _, child in ipairs(PLAYERS_FOLDER:GetChildren()) do
	task.spawn(function()
		handleModel(child)
	end)
end

-- watch for new models placed into the players folder
PLAYERS_FOLDER.ChildAdded:Connect(function(child)
	task.spawn(function()
		-- short delay for robustness
		task.wait(0.03)
		handleModel(child)
	end)
end)

-- fallback: also hook Player.CharacterAdded in case some characters are parented differently
Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(char)
		task.wait(0.03)
		handleModel(char)
	end)
	-- handle already-present character
	if player.Character then
		task.spawn(function()
			task.wait(0.03)
			handleModel(player.Character)
		end)
	end
end)

-- cover players that already exist when script runs
for _, p in ipairs(Players:GetPlayers()) do
	if p.Character then
		task.spawn(function()
			task.wait(0.03)
			handleModel(p.Character)
		end)
	end
end
